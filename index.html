<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShowTails OCR Pedigree Scanner</title>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f9fafb;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 {
      color: #333;
      margin-bottom: 0.5em;
    }
    #preview {
      margin-top: 15px;
      max-width: 90%;
      border: 1px solid #ccc;
      border-radius: 10px;
    }
    #progress {
      margin-top: 10px;
      color: #555;
    }
    #output {
      white-space: pre-wrap;
      text-align: left;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 15px;
      border-radius: 10px;
      font-family: monospace;
      max-height: 60vh;
      overflow: auto;
      background: #fff;
    }
  </style>
</head>
<body>

  <h1>üêá ShowTails OCR Pedigree Scanner</h1>
  <p>The image from Glide will be processed automatically. Once complete, copy the text below and paste it into Glide.</p>

  <div id="progress">Scanning...</div>
  <img id="preview" alt="Pedigree preview" />
  <div id="output"></div>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // ----------- MAIN OCR FUNCTION (4-generation slicing) -----------
    async function runOCR(imageUrl, progressEl, outputEl) {
      function updateProgress(m) {
        if (m.status === 'recognizing text') {
          progressEl.textContent = `Scanning: ${(m.progress * 100).toFixed(1)}%`;
        }
      }

      // Load the image into a canvas
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = imageUrl;
      await img.decode();

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const W = img.naturalWidth;
      const H = img.naturalHeight;
      canvas.width = W;
      canvas.height = H;
      ctx.drawImage(img, 0, 0);

      // Define the four vertical slices for each generation
      const generations = [
        { name: "Rabbit", x: 0,       w: W * 0.23 },  // Current rabbit
        { name: "Parents", x: W * 0.23, w: W * 0.25 }, // Sire/Dam
        { name: "Grandparents", x: W * 0.48, w: W * 0.25 }, // Grandparents
        { name: "GreatGrandparents", x: W * 0.73, w: W * 0.27 } // Great-grandparents
      ];

      const worker = await Tesseract.createWorker();
      worker.logger = updateProgress;

      await worker.loadLanguage('eng');
      await worker.initialize('eng');

      let combinedText = '';
      let confidences = [];

      // Process each generation independently
      for (let g of generations) {
        const crop = document.createElement('canvas');
        crop.width = g.w;
        crop.height = H;
        const cctx = crop.getContext('2d');
        cctx.drawImage(img, g.x, 0, g.w, H, 0, 0, g.w, H);

        const { data } = await worker.recognize(crop);
        combinedText += `\n\n=== ${g.name.toUpperCase()} ===\n\n` + data.text;
        if (data.confidence) confidences.push(data.confidence);
      }

      await worker.terminate();

      const avgConf = confidences.length
        ? (confidences.reduce((a, b) => a + b, 0) / confidences.length).toFixed(1)
        : 'N/A';

      // --- Run our parsing logic ---
      const clean = preClean(combinedText);
      const sections = segmentRabbits(clean);
      const rabbits = sections.map(parseSection);

      const readable = rabbits.map((r, i) => {
        const lines = [];
        lines.push(`=== Rabbit ${i + 1} (${r.Role}) ===`);
        if (r.Name) lines.push(`Name: ${r.Name}`);
        if (r.Variety) lines.push(`Variety: ${r.Variety}`);
        if (r.Ear) lines.push(`Ear #: ${r.Ear}`);
        if (r.Reg) lines.push(`Reg #: ${r.Reg}`);
        if (r.GC) lines.push(`GC #: ${r.GC}`);
        if (r.Weight) lines.push(`Weight: ${r.Weight}`);
        if (r.Legs) lines.push(`Legs: ${r.Legs}`);
        if (r.Born) lines.push(`Born: ${r.Born}`);
        lines.push('');
        return lines.join('\n');
      }).join('\n');

      outputEl.innerText =
        `‚úÖ OCR complete ‚Äî Average Confidence: ${avgConf}%\nCopy and paste this text into Glide:\n\n` +
        readable;

      progressEl.textContent = '‚úÖ OCR finished successfully.';
    }

    // ----------- CLEANING + PARSING UTILITIES -----------
    function preClean(s) {
      return s
        .replace(/\r/g, '\n')
        .replace(/\n{2,}/g, '\n')
        .replace(/[ \t]{2,}/g, ' ')
        .replace(/ariety/gi, 'Variety')
        .replace(/We[il1]?ght/gi, 'Weight')
        .replace(/Leg[s5]/gi, 'Legs')
        .replace(/\bRe[gq][\.\s#:]*/gi, 'Reg # ')
        .replace(/\bG\.?C\.?\b/gi, 'GC') // normalize G.C. to GC
        .replace(/[Ee]ar[\s#:]*/g, 'Ear # ')
        .replace(/\bBorn[\s:]*([0-9OIl\-\/\.]+)/gi, 'Born: $1')
        .replace(/([0-9])\s*[il1]b\b/gi, '$1 lb')
        .replace(/\b([0-9])\s*[o0]z\b/gi, '$1 oz')
        .replace(/[|]/g, ' ')
        .trim();
    }

    function segmentRabbits(s) {
      const marked = s.replace(/(?:^|\n{2,})(Name|Sire|Dam)\b\s*:?/gi, '\n=== $1 ===\n');
      const chunks = marked.split(/\n===\s*/).map(x => x.trim()).filter(Boolean);
      const result = [];
      for (const chunk of chunks) {
        const head = chunk.match(/^(Name|Sire|Dam)/i);
        const role = head ? head[1].toUpperCase() : 'UNKNOWN';
        result.push({ role, block: chunk });
      }
      return result;
    }

    function parseSection(sec) {
      const blk = ' ' + sec.block.replace(/\n/g, ' ') + ' ';
      const rx = {
        name: /(Name|Rabbit|Animal)[:\s]+([A-Za-z0-9'&\-\s]{3,})/,
        ear: /Ear\s*#[:\s]*([A-Z0-9\-]+)/i,
        reg: /Reg\s*#[:\s]*([A-Z0-9\-]+)/i,
        gc: /\bG\.?C\.?\s*#[:\s]*([A-Z0-9\-]+)/i,
        variety: /Variety[:\s]+([A-Za-z][A-Za-z\s\(\)\/\-]+?)(?=\b(Weight|Legs|Ear|Reg|GC|Born|Sire|Dam|$))/i,
        weight: /Weight[:\s]*([0-9]{1,2}\s*lb\s*[0-9]{1,2}\s*oz)/i,
        legs: /Legs?[:\s]*([0-9]{1,2})\b/i,
        born: /Born[:\s]*([0-9OIl\-\/\.]{6,12})/i
      };

      function grab(r) {
        const m = blk.match(r);
        return m ? (m[2] || m[1] || '').trim() : '';
      }

      const inferredName = !grab(rx.name) && /^(SIRE|DAM)/i.test(sec.role)
        ? grab(/^(?:Sire|Dam)[:\s]+([A-Za-z0-9'&\-\s]{3,})/i)
        : '';

      return {
        Role: sec.role,
        Name: grab(rx.name) || inferredName,
        Variety: grab(rx.variety),
        Ear: grab(rx.ear),
        Reg: grab(rx.reg),
        GC: grab(rx.gc),
        Weight: grab(rx.weight),
        Legs: grab(rx.legs),
        Born: normalizeDate(grab(rx.born))
      };
    }

    function normalizeDate(s) {
      if (!s) return '';
      const t = s.replace(/[O]/g, '0').replace(/[Il]/g, '1').replace(/\./g, '/').replace(/-/g, '/');
      const m = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
      if (!m) return s.trim();
      let [ , mm, dd, yy ] = m;
      if (yy.length === 2) yy = (+yy >= 70 ? '19' : '20') + yy;
      return `${mm.padStart(2,'0')}/${dd.padStart(2,'0')}/${yy}`;
    }

    // ----------- PAGE STARTUP -----------
    const params = new URLSearchParams(location.search);
    const imageUrl = params.get('image');
    const progress = document.getElementById('progress');
    const output = document.getElementById('output');
    const preview = document.getElementById('preview');

    if (imageUrl) {
      preview.src = imageUrl;
      runOCR(imageUrl, progress, output).catch(err => {
        progress.textContent = '‚ùå OCR failed: ' + (err?.message || err);
      });
    } else {
      progress.textContent = '‚ùå No image URL detected. Add ?image= to your link.';
    }
  </script>
</body>
</html>
