<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShowTails OCR Pedigree Scanner</title>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f9fafb;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 {
      color: #333;
      margin-bottom: 0.5em;
    }
    #preview {
      margin-top: 15px;
      max-width: 90%;
      border: 1px solid #ccc;
      border-radius: 10px;
    }
    #progress {
      margin-top: 10px;
      color: #555;
    }
    #output {
      white-space: pre-wrap;
      text-align: left;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 15px;
      border-radius: 10px;
      font-family: monospace;
      max-height: 60vh;
      overflow: auto;
      background: #fff;
    }
  </style>
</head>
<body>

  <h1>üêá ShowTails OCR Pedigree Scanner</h1>
  <p>The image from Glide will be processed automatically. Once complete, copy the text below and paste it into Glide.</p>

  <div id="progress">Scanning...</div>
  <img id="preview" alt="Pedigree preview" />
  <div id="output"></div>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    async function runOCR(imageUrl, progressEl, outputEl) {
      function updateProgress(m) {
        if (m.status === 'recognizing text') {
          progressEl.textContent = `Scanning: ${(m.progress * 100).toFixed(1)}%`;
        }
      }

      const worker = await Tesseract.createWorker();
      worker.logger = updateProgress;

      await worker.loadLanguage('eng');
      await worker.initialize('eng');

      const { data } = await worker.recognize(imageUrl);
      await worker.terminate();

      const confidence = data.confidence ? data.confidence.toFixed(1) : 'N/A';
      const text = data.text;

      const clean = preClean(text);
      const sections = segmentRabbits(clean);
      const rabbits = sections.map(parseSection);

      const readable = rabbits.map((r, i) => {
        const lines = [];
        lines.push(`=== Rabbit ${i + 1} (${r.Role}) ===`);
        if (r.Name) lines.push(`Name: ${r.Name}`);
        if (r.Variety) lines.push(`Variety: ${r.Variety}`);
        if (r.Ear) lines.push(`Ear #: ${r.Ear}`);
        if (r.Reg) lines.push(`Reg #: ${r.Reg}`);
        if (r.GC) lines.push(`GC #: ${r.GC}`);
        if (r.Weight) lines.push(`Weight: ${r.Weight}`);
        if (r.Legs) lines.push(`Legs: ${r.Legs}`);
        if (r.Born) lines.push(`Born: ${r.Born}`);
        lines.push('');
        return lines.join('\n');
      }).join('\n');

      const summary = `‚úÖ OCR complete ‚Äî Average Confidence: ${confidence}%\nCopy and paste this text into Glide:\n\n`;
      outputEl.innerText = summary + readable;

      progressEl.textContent = '‚úÖ OCR finished successfully.';
    }

    // ---------- Helper functions ----------

    function preClean(s) {
      return s
        .replace(/\r/g, '\n')
        .replace(/\n{2,}/g, '\n')
        .replace(/[ \t]{2,}/g, ' ')
        .replace(/ariety/gi, 'Variety')
        .replace(/We[il1]?ght/gi, 'Weight')
        .replace(/Leg[s5]/gi, 'Legs')
        .replace(/\bRe[gq][\.\s#:]*/gi, 'Reg # ')
        .replace(/\bG\.?C\.?\b/gi, 'GC') // normalize G.C. to GC
        .replace(/[Ee]ar[\s#:]*/g, 'Ear # ')
        .replace(/\bBorn[\s:]*([0-9OIl\-\/\.]+)/gi, 'Born: $1')
        .replace(/([0-9])\s*[il1]b\b/gi, '$1 lb')
        .replace(/\b([0-9])\s*[o0]z\b/gi, '$1 oz')
        .replace(/[|]/g, ' ')
        .trim();
    }

    // Updated segmentation (block-level only)
    function segmentRabbits(s) {
      const marked = s.replace(/(?:^|\n{2,})(Name|Sire|Dam)\b\s*:?/gi, '\n=== $1 ===\n');
      const chunks = marked.split(/\n===\s*/).map(x => x.trim()).filter(Boolean);
      const result = [];
      for (const chunk of chunks) {
        const head = chunk.match(/^(Name|Sire|Dam)/i);
        const role = head ? head[1].toUpperCase() : 'UNKNOWN';
        result.push({ role, block: chunk });
      }
      return result;
    }

    function roleRank(role) {
      const order = { 'NAME': 0, 'SIRE': 1, 'DAM': 2, 'UNKNOWN': 3 };
      return order[role] ?? 3;
    }

    function parseSection(sec) {
      const blk = ' ' + sec.block.replace(/\n/g, ' ') + ' ';
      const rx = {
        name: /(Name|Rabbit|Animal)[:\s]+([A-Za-z0-9'&\-\s]{3,})/,
        ear: /Ear\s*#[:\s]*([A-Z0-9\-]+)/i,
        reg: /Reg\s*#[:\s]*([A-Z0-9\-]+)/i,
        gc: /\bG\.?C\.?\s*#[:\s]*([A-Z0-9\-]+)/i,
        variety: /Variety[:\s]+([A-Za-z][A-Za-z\s\(\)\/\-]+?)(?=\b(Weight|Legs|Ear|Reg|GC|Born|Sire|Dam|$))/i,
        weight: /Weight[:\s]*([0-9]{1,2}\s*lb\s*[0-9]{1,2}\s*oz)/i,
        legs: /Legs?[:\s]*([0-9]{1,2})\b/i,
        born: /Born[:\s]*([0-9OIl\-\/\.]{6,12})/i
      };

      function grab(r) {
        const m = blk.match(r);
        return m ? (m[2] || m[1] || '').trim() : '';
      }

      const inferredName = !grab(rx.name) && /^(SIRE|DAM)/i.test(sec.role)
        ? grab(/^(?:Sire|Dam)[:\s]+([A-Za-z0-9'&\-\s]{3,})/i)
        : '';

      return {
        Role: sec.role,
        Name: grab(rx.name) || inferredName,
        Variety: grab(rx.variety),
        Ear: grab(rx.ear),
        Reg: grab(rx.reg),
        GC: grab(rx.gc),
        Weight: grab(rx.weight),
        Legs: grab(rx.legs),
        Born: normalizeDate(grab(rx.born))
      };
    }

    function normalizeDate(s) {
      if (!s) return '';
      const t = s.replace(/[O]/g, '0').replace(/[Il]/g, '1').replace(/\./g, '/').replace(/-/g, '/');
      const m = t.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
      if (!m) return s.trim();
      let [ , mm, dd, yy ] = m;
      if (yy.length === 2) yy = (+yy >= 70 ? '19' : '20') + yy;
      return `${mm.padStart(2,'0')}/${dd.padStart(2,'0')}/${yy}`;
    }

    // ---------- Startup ----------
    const params = new URLSearchParams(location.search);
    const imageUrl = params.get('image');
    const progress = document.getElementById('progress');
    const output = document.getElementById('output');
    const preview = document.getElementById('preview');

    if (imageUrl) {
      preview.src = imageUrl;
      runOCR(imageUrl, progress, output).catch(err => {
        progress.textContent = '‚ùå OCR failed: ' + (err?.message || err);
      });
    } else {
      progress.textContent = '‚ùå No image URL detected. Add ?image= to your link.';
    }
  </script>
</body>
</html>
üß© What‚Äôs New
‚úÖ Confidence Score: displayed as Average Confidence: 87.4% (example) at the top of the output.
‚úÖ Divider Lines: output sections now clearly show
=== Rabbit 1 (SIRE) === for easier visual verification and structured parsing.
‚úÖ Fully compatible with your Cloudflare proxy Glide embed setup.

After uploading this:

Re-run your pedigree through Glide ‚Üí the output should show cleanly formatted, clearly separated rabbits.

Copy everything (including divider lines) into your ‚ÄúOCR Raw Text‚Äù field.

Would you like me to next help you design a matching Glide regex/split setup that recogni





