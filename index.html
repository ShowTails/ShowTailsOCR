<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShowTails OCR Pedigree Scanner</title>

  <style>
    body {
      font-family: system-ui, sans-serif;
      background-color: #f9fafb;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 {
      color: #333;
      margin-bottom: 0.5em;
    }
    #preview {
      margin-top: 15px;
      max-width: 90%;
      border: 1px solid #ccc;
      border-radius: 10px;
    }
    #progress {
      margin-top: 10px;
      color: #555;
    }
    #output {
      white-space: pre-wrap;
      text-align: left;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 15px;
      border-radius: 10px;
      font-family: monospace;
      max-height: 60vh;
      overflow: auto;
      background: #fff;
    }
  </style>
</head>
<body>

  <h1>üêá ShowTails OCR Pedigree Scanner</h1>
  <p>The image from Glide will be processed automatically. Once complete, copy the text below and paste it into Glide.</p>

  <div id="progress">Scanning...</div>
  <img id="preview" alt="Pedigree preview" />
  <div id="output"></div>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // ----------- MAIN OCR FUNCTION -----------
    async function runOCR(imageUrl, progressEl, outputEl) {
      function updateProgress(m) {
        if (m.status === 'recognizing text') {
          progressEl.textContent = `Scanning: ${(m.progress * 100).toFixed(1)}%`;
        }
      }

      // Load image into a canvas
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = imageUrl;
      await img.decode();

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const W = img.naturalWidth;
      const H = img.naturalHeight;
      canvas.width = W;
      canvas.height = H;
      ctx.drawImage(img, 0, 0);

      // ----------- IMAGE PRE-PROCESSING -----------
      const imageData = ctx.getImageData(0, 0, W, H);
      const dataArr = imageData.data;
      for (let i = 0; i < dataArr.length; i += 4) {
        const avg = (dataArr[i] + dataArr[i + 1] + dataArr[i + 2]) / 3;
        const val = avg > 180 ? 255 : 0; // threshold; lower if text is faint
        dataArr[i] = dataArr[i + 1] = dataArr[i + 2] = val;
      }
      ctx.putImageData(imageData, 0, 0);

      // Define four generation slices
      const generations = [
        { name: "Rabbit", x: 0,        w: W * 0.22 },
        { name: "Parents", x: W * 0.22, w: W * 0.24 },
        { name: "Grandparents", x: W * 0.46, w: W * 0.26 },
        { name: "GreatGrandparents", x: W * 0.72, w: W * 0.28 }
      ];

      // Create and configure Tesseract worker (CDN-safe)
      const worker = await Tesseract.createWorker();
      worker.logger = updateProgress;

      await worker.loadLanguage('eng');
      await worker.initialize('eng');
      await worker.setParameters({
        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_COLUMN,
        preserve_interword_spaces: '1'
      });

      let combinedText = '';
      let confidences = [];

      // Run OCR for each generation
      for (let g of generations) {
        const crop = document.createElement('canvas');
        crop.width = g.w;
        crop.height = H;
        const cctx = crop.getContext('2d');
        cctx.drawImage(img, g.x, 0, g.w, H, 0, 0, g.w, H);

        const { data } = await worker.recognize(crop);
        combinedText += `\n\n=== ${g.name.toUpperCase()} ===\n\n` + data.text;
        if (data.confidence) confidences.push(data.confidence);
      }

      await worker.terminate();

      const avgConf = confidences.length
        ? (confidences.reduce((a, b) => a + b, 0) / confidences.length).toFixed(1)
        : 'N/A';

      // --- Parsing & Output ---
      const clean = preClean(combinedText);
      const sections = segmentRabbits(clean);
      const rabbits = sections.map(parseSection);

      const readable = rabbits.map((r, i) => {
        const lines = [];
        lines.push(`=== Rabbit ${i + 1} (${r.Role}) ===`);
        if (r.Name) lines.push(`Name: ${r.Name}`);
        if (r.Variety) lines.push(`Variety: ${r.Variety}`);
        if (r.Ear) lines.push(`Ear #: ${r.Ear}`);
        if (r.Reg) lines.push(`Reg #: ${r.Reg}`);
        if (r.GC) lines.push(`GC #: ${r.GC}`);
        if (r.Weight) lines.push(`Weight: ${r.Weight}`);
        if (r.Legs) lines.push(`Legs: ${r.Legs}`);
        if (r.Born) lines.push(`Born: ${r.Born}`);
        lines.push('');
        return lines.join('\n');
      }).join('\n');

      outputEl.innerText =
        `‚úÖ OCR complete ‚Äî Average Confidence: ${avgConf}%\nCopy and paste this text into Glide:\n\n` +
        readable;

      progressEl.textContent = '‚úÖ OCR finished successfully.';
    }

    // ----------- CLEANING + PARSING UTILITIES -----------
    function preClean(s) {
      return s
        .replace(/\r/g, '\n')
        .replace(/\n{2,}/g, '\n')
        .replace(/[ \t]{2,}/g, ' ')
        .replace(/ariety/gi, 'Variety')
        .replace(/We[il1]?ght/gi, 'Weight')
        .replace(/Leg[s5]/gi, 'Legs')
        .replace(/\bRe[gq][\.\s#:]*/gi, 'Reg # ')
        .replace(/\bG\.?C\.?\b/gi, 'GC')
        .replace(/[Ee]ar[\s#:]*/g, 'Ear # ')
        .replace(/\bBorn[\s:]*([0-9OIl\-\/\.]+)/gi, 'Born: $1')
        .replace(/([0-9])\s*[il1]b\b/gi, '$1 lb')
        .replace(/\b([0-9])\s*[o0]z\b/gi, '$1 oz')
        .replace(/[|]/g, ' ')
        .trim();
    }

    function segmentRabbits(s) {
      const marked = s.replace(/(?:^|\n{2,})(Name|Sire|Dam)\b\s*:?/gi, '\n=== $1 ===\n');
      const chunks = marked.split(/\n===\s*/).map(x => x.trim()).filter(Boolean);
      const result = [];
      for (const chunk of chunks) {
        const head = chunk.match(/^(Name|Sire|Dam)/i);
        const role = head ? head[1].toUpperCase() : 'UNKNOWN';
        result.push({ role, block: chunk });
      }
      return result;
    }

    function parseSection(sec) {
      const blk = ' ' + sec.block.replace(/\n/g, ' ') + ' ';
      const rx = {
        name: /(Name|Rabbit|Animal)[:\s]+([A-Za-z0-9'&\-\s]{3,})/,
        ear: /Ear\s*#[:\s]*([A-Z0-9\-]+)/i,
        reg: /Reg\s*#[:\s]*([A-Z0-9\-]+)/i,
        gc: /\bG\.?C\.?
